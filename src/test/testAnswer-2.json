{
    "answer": "When someone sends a Bitcoin transaction, it goes through a multi-stage validation and propagation process in Bitcoin Core. Here's the detailed flow:\n\n## 1. Initial Reception and Format Validation\n\nWhen a transaction is received (via RPC or P2P network), it first enters the validation pipeline in **src/validation.cpp**. The process begins with the `AcceptToMemoryPool()` function (around line 1034), which calls `AcceptToMemoryPoolWithTime()`.\n\nThe first check happens in the `CheckTransaction()` function in **src/consensus/tx_verify.cpp**:\n\n```cpp\nbool CheckTransaction(const CTransaction& tx, TxValidationState& state)\n{\n    // Basic checks that don't depend on any context\n    if (tx.vin.empty())\n        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-vin-empty\");\n    if (tx.vout.empty())\n        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-vout-empty\");\n    \n    // Check for negative or overflow output values\n    CAmount nValueOut = 0;\n    for (const auto& txout : tx.vout) {\n        if (txout.nValue < 0)\n            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-vout-negative\");\n    }\n}\n```\n\n## 2. Script and Signature Validation\n\nNext, the transaction undergoes script validation in **src/validation.cpp** within the `CheckInputScripts()` function:\n\n```cpp\nbool CheckInputScripts(const CTransaction& tx, TxValidationState& state,\n                      const CCoinsViewCache& inputs, unsigned int flags,\n                      bool cacheSigStore, bool cacheFullScriptStore,\n                      PrecomputedTransactionData& txdata,\n                      std::vector<CScriptCheck>* pvChecks)\n{\n    if (tx.IsCoinBase()) return true;\n\n    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n        const COutPoint &prevout = tx.vin[i].prevout;\n        const Coin& coin = inputs.AccessCoin(prevout);\n        \n        // Verify signature and execute scripts\n        CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n        if (pvChecks) {\n            pvChecks->push_back(CScriptCheck());\n            check.swap(pvChecks->back());\n        } else if (!check()) {\n            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"script-validation-error\");\n        }\n    }\n}\n```\n\n## 3. Mempool Acceptance\n\nIf validation passes, the transaction attempts to enter the mempool via the `CTxMemPool` class defined in **src/txmempool.h**. The `addUnchecked()` method in **src/txmempool.cpp** handles the actual insertion:\n\n```cpp\nvoid CTxMemPool::addUnchecked(const CTxMemPoolEntry &entry, bool validFeeEstimate)\n{\n    indexed_transaction_set::iterator newit = mapTx.insert(entry).first;\n    mapLinks.insert(make_pair(newit, TxLinks()));\n    \n    // Update cached inner usage to include the new entry\n    cachedInnerUsage += entry.DynamicMemoryUsage();\n    const CTransaction& tx = newit->GetTx();\n    \n    // Add to fee-based indexes for mining prioritization\n    mapDeltas.insert(std::make_pair(tx.GetHash(), PriorityFeeDelta()));\n}\n```\n\n## 4. Validation Result Handling\n\nThroughout this process, validation results are tracked using the `TxValidationResult` enum from **src/consensus/validation.h**:\n\n```cpp\nenum class TxValidationResult {\n    TX_RESULT_UNSET = 0,        //!< Initial value\n    TX_CONSENSUS,               //!< Invalid by consensus rules\n    TX_MISSING_INPUTS,          //!< Transaction inputs are missing\n    TX_CONFLICT,                //!< Transaction conflicts with something\n    TX_MEMPOOL_POLICY,          //!< Violated non-mandatory mempool policy\n    TX_NO_MEMPOOL,              //!< Not in mempool for other reason\n};\n```\n\n## 5. Network Propagation\n\nOnce accepted to the mempool, the transaction is announced to peers through the P2P network code in **src/net_processing.cpp**. The `RelayTransaction()` function handles broadcasting:\n\n```cpp\nvoid PeerManagerImpl::RelayTransaction(const uint256& txid, const uint256& wtxid)\n{\n    WITH_LOCK(cs_main, PeerManagerImpl::RelayTransactionLocked(txid, wtxid));\n}\n```\n\n## Key Data Structures and Thread Safety\n\nThe mempool is protected by the `cs` recursive mutex defined in **src/txmempool.h**:\n\n```cpp\nclass CTxMemPool {\nprivate:\n    mutable RecursiveMutex cs;  //!< Synchronizes access to mempool data\n    indexed_transaction_set mapTx GUARDED_BY(cs);\n    typedef std::map<txiter, TxLinks, CompareIteratorByHash> txlinksMap;\n    txlinksMap mapLinks GUARDED_BY(cs);\n};\n```\n\n## Related Files to Explore\n\n- **src/validation.cpp**: Main validation logic and mempool integration\n- **src/txmempool.cpp**: Core mempool implementation and fee prioritization  \n- **src/script/interpreter.cpp**: Script execution engine\n- **src/net_processing.cpp**: P2P transaction relay logic\n- **src/rpc/rawtransaction.cpp**: RPC interfaces for transaction submission\n\nFor deeper understanding of Bitcoin Core's transaction handling, I recommend reviewing the [Bitcoin Core developer documentation](https://bitcoincore.org/en/doc/) and the [Bitcoin Optech mempool guide](https://bitcoinops.org/en/topics/transaction-pool-management/) which covers the implementation details extensively.",
    "context_documents": 3,
    "question": "What happens when someone sends a bitcoin transaction?",
    "sources_used": [
        "developer-notes.md",
        "bitcoinops.org/mempool-guide",
        "src/consensus/validation.h"
    ],
    "success": true
}